# Defopaque

An experiment in defining 'newtypes' in Elixir.

## Motivating example

Let's define a `Units` module with a `kg` constructor, wrapping any number.

```
defmodule Units do
  use Defopaque
  defopen(:kg, number())
end
```

Using `defopen` gives us:

1) A `kg()` `@type`, exported from `Units`.

2) A `kg(n)` marco, which will generate a tuple containing the `number()` `n`
as its second element. The first element of the tuple will be an autogenerated
atom (guaranteed to be stable for every `{wrapper-atom, wrapped-subtype}`
pair).  We can use this macro to generate new `kg` values *and* to
pattern-match on existing values.

Let's see some examples of the `kg` unit in use:

```
defmodule MyApp do
  import Units

  @spec tell_weight(Units.kg()) :: String.t()
  def tell_weight(w) do
    case w do
      kg(12) -> "twelve kilograms"
      kg(other) -> "#{other} kg"
      _ -> "invalid unit"
    end
  end
end
```

```
require Units
iex()> MyApp.tell_weight(Units.kg(12))
"twelve kilograms"
iex()> MyApp.tell_weight(Units.kg(11))
"11kg"
iex()> MyApp.tell_weight(12)
"invalid unit"
```

You can also use pattern-match syntax to match on values *inside* the constructor:

```
defmodule Matches do
  import Units

  def count(want_value) do
    weights = [kg(1), kg(3.9), kg(5.3), kg(10.1)]
    Enum.count(weights,
      fn kg(^want_value) -> true
         kg(_) -> false
      end)
  end
end
```

```
iex(19)> Matches.count(3.90)
1
iex(20)> Matches.count(3.91)
0
```


## Why not tagged tuples?

Tagged tuples are the standard way to handle this type of problem and there's
really nothing with them, but they don't prevent 'unauthorized' use of our
types.

For example, there's no reason why some module that should know nothing about
weights couldn't  match on our tagged tuple:

```
def an_allegedly_weight_agnostic_function({:kg, weight}) do
```

With this method, code that does not reference our `Units` module cannot in good faith access our tag, since it's more-or-less gibberish.

Also, unique and opaque tags mean that dialyzer can be much more strict when
checking our code.


